/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_CatalogMetadataDetails.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


CatalogMetadataDetails::~CatalogMetadataDetails() noexcept {
}


void CatalogMetadataDetails::__set_names(const std::vector<std::string> & val) {
  this->names = val;
__isset.names = true;
}

void CatalogMetadataDetails::__set_properties(const std::vector<std::map<std::string, std::string> > & val) {
  this->properties = val;
__isset.properties = true;
}

void CatalogMetadataDetails::__set_newProperties(const std::vector<std::map<std::string, std::string> > & val) {
  this->newProperties = val;
__isset.newProperties = true;
}

void CatalogMetadataDetails::__set_catalogSchemaVersion(const int64_t val) {
  this->catalogSchemaVersion = val;
__isset.catalogSchemaVersion = true;
}

void CatalogMetadataDetails::__set_exists(const bool val) {
  this->exists = val;
__isset.exists = true;
}

void CatalogMetadataDetails::__set_otherFlags(const std::vector<int32_t> & val) {
  this->otherFlags = val;
__isset.otherFlags = true;
}

void CatalogMetadataDetails::__set_catalogSchema(const CatalogSchemaObject& val) {
  this->catalogSchema = val;
__isset.catalogSchema = true;
}

void CatalogMetadataDetails::__set_catalogTable(const CatalogTableObject& val) {
  this->catalogTable = val;
__isset.catalogTable = true;
}

void CatalogMetadataDetails::__set_catalogFunction(const CatalogFunctionObject& val) {
  this->catalogFunction = val;
__isset.catalogFunction = true;
}

void CatalogMetadataDetails::__set_catalogPartitions(const std::vector<CatalogPartitionObject> & val) {
  this->catalogPartitions = val;
__isset.catalogPartitions = true;
}

uint32_t CatalogMetadataDetails::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->names.clear();
            uint32_t _size446;
            ::apache::thrift::protocol::TType _etype449;
            xfer += iprot->readListBegin(_etype449, _size446);
            this->names.resize(_size446);
            uint32_t _i450;
            for (_i450 = 0; _i450 < _size446; ++_i450)
            {
              xfer += iprot->readString(this->names[_i450]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.names = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->properties.clear();
            uint32_t _size451;
            ::apache::thrift::protocol::TType _etype454;
            xfer += iprot->readListBegin(_etype454, _size451);
            this->properties.resize(_size451);
            uint32_t _i455;
            for (_i455 = 0; _i455 < _size451; ++_i455)
            {
              {
                this->properties[_i455].clear();
                uint32_t _size456;
                ::apache::thrift::protocol::TType _ktype457;
                ::apache::thrift::protocol::TType _vtype458;
                xfer += iprot->readMapBegin(_ktype457, _vtype458, _size456);
                uint32_t _i460;
                for (_i460 = 0; _i460 < _size456; ++_i460)
                {
                  std::string _key461;
                  xfer += iprot->readString(_key461);
                  std::string& _val462 = this->properties[_i455][_key461];
                  xfer += iprot->readString(_val462);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->newProperties.clear();
            uint32_t _size463;
            ::apache::thrift::protocol::TType _etype466;
            xfer += iprot->readListBegin(_etype466, _size463);
            this->newProperties.resize(_size463);
            uint32_t _i467;
            for (_i467 = 0; _i467 < _size463; ++_i467)
            {
              {
                this->newProperties[_i467].clear();
                uint32_t _size468;
                ::apache::thrift::protocol::TType _ktype469;
                ::apache::thrift::protocol::TType _vtype470;
                xfer += iprot->readMapBegin(_ktype469, _vtype470, _size468);
                uint32_t _i472;
                for (_i472 = 0; _i472 < _size468; ++_i472)
                {
                  std::string _key473;
                  xfer += iprot->readString(_key473);
                  std::string& _val474 = this->newProperties[_i467][_key473];
                  xfer += iprot->readString(_val474);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.newProperties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->catalogSchemaVersion);
          this->__isset.catalogSchemaVersion = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->exists);
          this->__isset.exists = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->otherFlags.clear();
            uint32_t _size475;
            ::apache::thrift::protocol::TType _etype478;
            xfer += iprot->readListBegin(_etype478, _size475);
            this->otherFlags.resize(_size475);
            uint32_t _i479;
            for (_i479 = 0; _i479 < _size475; ++_i479)
            {
              xfer += iprot->readI32(this->otherFlags[_i479]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.otherFlags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogSchema.read(iprot);
          this->__isset.catalogSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogTable.read(iprot);
          this->__isset.catalogTable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->catalogFunction.read(iprot);
          this->__isset.catalogFunction = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->catalogPartitions.clear();
            uint32_t _size480;
            ::apache::thrift::protocol::TType _etype483;
            xfer += iprot->readListBegin(_etype483, _size480);
            this->catalogPartitions.resize(_size480);
            uint32_t _i484;
            for (_i484 = 0; _i484 < _size480; ++_i484)
            {
              xfer += this->catalogPartitions[_i484].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.catalogPartitions = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CatalogMetadataDetails::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CatalogMetadataDetails");

  if (this->__isset.names) {
    xfer += oprot->writeFieldBegin("names", ::apache::thrift::protocol::T_LIST, 1);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->names.size()));
      std::vector<std::string> ::const_iterator _iter485;
      for (_iter485 = this->names.begin(); _iter485 != this->names.end(); ++_iter485)
      {
        xfer += oprot->writeString((*_iter485));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.properties) {
    xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->properties.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter486;
      for (_iter486 = this->properties.begin(); _iter486 != this->properties.end(); ++_iter486)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter486).size()));
          std::map<std::string, std::string> ::const_iterator _iter487;
          for (_iter487 = (*_iter486).begin(); _iter487 != (*_iter486).end(); ++_iter487)
          {
            xfer += oprot->writeString(_iter487->first);
            xfer += oprot->writeString(_iter487->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.newProperties) {
    xfer += oprot->writeFieldBegin("newProperties", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->newProperties.size()));
      std::vector<std::map<std::string, std::string> > ::const_iterator _iter488;
      for (_iter488 = this->newProperties.begin(); _iter488 != this->newProperties.end(); ++_iter488)
      {
        {
          xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter488).size()));
          std::map<std::string, std::string> ::const_iterator _iter489;
          for (_iter489 = (*_iter488).begin(); _iter489 != (*_iter488).end(); ++_iter489)
          {
            xfer += oprot->writeString(_iter489->first);
            xfer += oprot->writeString(_iter489->second);
          }
          xfer += oprot->writeMapEnd();
        }
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogSchemaVersion) {
    xfer += oprot->writeFieldBegin("catalogSchemaVersion", ::apache::thrift::protocol::T_I64, 4);
    xfer += oprot->writeI64(this->catalogSchemaVersion);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.exists) {
    xfer += oprot->writeFieldBegin("exists", ::apache::thrift::protocol::T_BOOL, 5);
    xfer += oprot->writeBool(this->exists);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.otherFlags) {
    xfer += oprot->writeFieldBegin("otherFlags", ::apache::thrift::protocol::T_LIST, 6);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->otherFlags.size()));
      std::vector<int32_t> ::const_iterator _iter490;
      for (_iter490 = this->otherFlags.begin(); _iter490 != this->otherFlags.end(); ++_iter490)
      {
        xfer += oprot->writeI32((*_iter490));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogSchema) {
    xfer += oprot->writeFieldBegin("catalogSchema", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->catalogSchema.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogTable) {
    xfer += oprot->writeFieldBegin("catalogTable", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->catalogTable.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogFunction) {
    xfer += oprot->writeFieldBegin("catalogFunction", ::apache::thrift::protocol::T_STRUCT, 9);
    xfer += this->catalogFunction.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.catalogPartitions) {
    xfer += oprot->writeFieldBegin("catalogPartitions", ::apache::thrift::protocol::T_LIST, 10);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->catalogPartitions.size()));
      std::vector<CatalogPartitionObject> ::const_iterator _iter491;
      for (_iter491 = this->catalogPartitions.begin(); _iter491 != this->catalogPartitions.end(); ++_iter491)
      {
        xfer += (*_iter491).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CatalogMetadataDetails &a, CatalogMetadataDetails &b) {
  using ::std::swap;
  swap(a.names, b.names);
  swap(a.properties, b.properties);
  swap(a.newProperties, b.newProperties);
  swap(a.catalogSchemaVersion, b.catalogSchemaVersion);
  swap(a.exists, b.exists);
  swap(a.otherFlags, b.otherFlags);
  swap(a.catalogSchema, b.catalogSchema);
  swap(a.catalogTable, b.catalogTable);
  swap(a.catalogFunction, b.catalogFunction);
  swap(a.catalogPartitions, b.catalogPartitions);
  swap(a.__isset, b.__isset);
}

CatalogMetadataDetails::CatalogMetadataDetails(const CatalogMetadataDetails& other492) {
  names = other492.names;
  properties = other492.properties;
  newProperties = other492.newProperties;
  catalogSchemaVersion = other492.catalogSchemaVersion;
  exists = other492.exists;
  otherFlags = other492.otherFlags;
  catalogSchema = other492.catalogSchema;
  catalogTable = other492.catalogTable;
  catalogFunction = other492.catalogFunction;
  catalogPartitions = other492.catalogPartitions;
  __isset = other492.__isset;
}
CatalogMetadataDetails::CatalogMetadataDetails( CatalogMetadataDetails&& other493) noexcept {
  names = std::move(other493.names);
  properties = std::move(other493.properties);
  newProperties = std::move(other493.newProperties);
  catalogSchemaVersion = std::move(other493.catalogSchemaVersion);
  exists = std::move(other493.exists);
  otherFlags = std::move(other493.otherFlags);
  catalogSchema = std::move(other493.catalogSchema);
  catalogTable = std::move(other493.catalogTable);
  catalogFunction = std::move(other493.catalogFunction);
  catalogPartitions = std::move(other493.catalogPartitions);
  __isset = std::move(other493.__isset);
}
CatalogMetadataDetails& CatalogMetadataDetails::operator=(const CatalogMetadataDetails& other494) {
  names = other494.names;
  properties = other494.properties;
  newProperties = other494.newProperties;
  catalogSchemaVersion = other494.catalogSchemaVersion;
  exists = other494.exists;
  otherFlags = other494.otherFlags;
  catalogSchema = other494.catalogSchema;
  catalogTable = other494.catalogTable;
  catalogFunction = other494.catalogFunction;
  catalogPartitions = other494.catalogPartitions;
  __isset = other494.__isset;
  return *this;
}
CatalogMetadataDetails& CatalogMetadataDetails::operator=(CatalogMetadataDetails&& other495) noexcept {
  names = std::move(other495.names);
  properties = std::move(other495.properties);
  newProperties = std::move(other495.newProperties);
  catalogSchemaVersion = std::move(other495.catalogSchemaVersion);
  exists = std::move(other495.exists);
  otherFlags = std::move(other495.otherFlags);
  catalogSchema = std::move(other495.catalogSchema);
  catalogTable = std::move(other495.catalogTable);
  catalogFunction = std::move(other495.catalogFunction);
  catalogPartitions = std::move(other495.catalogPartitions);
  __isset = std::move(other495.__isset);
  return *this;
}
void CatalogMetadataDetails::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CatalogMetadataDetails(";
  out << "names="; (__isset.names ? (out << to_string(names)) : (out << "<null>"));
  out << ", " << "properties="; (__isset.properties ? (out << to_string(properties)) : (out << "<null>"));
  out << ", " << "newProperties="; (__isset.newProperties ? (out << to_string(newProperties)) : (out << "<null>"));
  out << ", " << "catalogSchemaVersion="; (__isset.catalogSchemaVersion ? (out << to_string(catalogSchemaVersion)) : (out << "<null>"));
  out << ", " << "exists="; (__isset.exists ? (out << to_string(exists)) : (out << "<null>"));
  out << ", " << "otherFlags="; (__isset.otherFlags ? (out << to_string(otherFlags)) : (out << "<null>"));
  out << ", " << "catalogSchema="; (__isset.catalogSchema ? (out << to_string(catalogSchema)) : (out << "<null>"));
  out << ", " << "catalogTable="; (__isset.catalogTable ? (out << to_string(catalogTable)) : (out << "<null>"));
  out << ", " << "catalogFunction="; (__isset.catalogFunction ? (out << to_string(catalogFunction)) : (out << "<null>"));
  out << ", " << "catalogPartitions="; (__isset.catalogPartitions ? (out << to_string(catalogPartitions)) : (out << "<null>"));
  out << ")";
}

}}} // namespace
