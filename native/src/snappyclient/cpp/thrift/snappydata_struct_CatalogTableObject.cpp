/**
 * Autogenerated by Thrift Compiler (0.10.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>
#include "snappydata_struct_CatalogTableObject.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace io { namespace snappydata { namespace thrift {


CatalogTableObject::~CatalogTableObject() noexcept {
}


void CatalogTableObject::__set_tableName(const std::string& val) {
  this->tableName = val;
}

void CatalogTableObject::__set_schemaName(const std::string& val) {
  this->schemaName = val;
__isset.schemaName = true;
}

void CatalogTableObject::__set_tableType(const std::string& val) {
  this->tableType = val;
}

void CatalogTableObject::__set_storage(const CatalogStorage& val) {
  this->storage = val;
}

void CatalogTableObject::__set_tableSchema(const std::string& val) {
  this->tableSchema = val;
}

void CatalogTableObject::__set_provider(const std::string& val) {
  this->provider = val;
__isset.provider = true;
}

void CatalogTableObject::__set_partitionColumns(const std::vector<std::string> & val) {
  this->partitionColumns = val;
}

void CatalogTableObject::__set_indexColumns(const std::vector<std::string> & val) {
  this->indexColumns = val;
}

void CatalogTableObject::__set_primaryKeyColumns(const std::vector<std::string> & val) {
  this->primaryKeyColumns = val;
}

void CatalogTableObject::__set_numBuckets(const int32_t val) {
  this->numBuckets = val;
__isset.numBuckets = true;
}

void CatalogTableObject::__set_redundancy(const int32_t val) {
  this->redundancy = val;
__isset.redundancy = true;
}

void CatalogTableObject::__set_bucketOwners(const std::vector<BucketOwners> & val) {
  this->bucketOwners = val;
}

void CatalogTableObject::__set_bucketColumns(const std::vector<std::string> & val) {
  this->bucketColumns = val;
}

void CatalogTableObject::__set_sortColumns(const std::vector<std::string> & val) {
  this->sortColumns = val;
}

void CatalogTableObject::__set_owner(const std::string& val) {
  this->owner = val;
}

void CatalogTableObject::__set_createTime(const int64_t val) {
  this->createTime = val;
}

void CatalogTableObject::__set_lastAccessTime(const int64_t val) {
  this->lastAccessTime = val;
}

void CatalogTableObject::__set_properties(const std::map<std::string, std::string> & val) {
  this->properties = val;
}

void CatalogTableObject::__set_sizeInBytes(const int64_t val) {
  this->sizeInBytes = val;
__isset.sizeInBytes = true;
}

void CatalogTableObject::__set_rowCount(const int64_t val) {
  this->rowCount = val;
__isset.rowCount = true;
}

void CatalogTableObject::__set_colStats(const std::vector<std::map<std::string, std::string> > & val) {
  this->colStats = val;
}

void CatalogTableObject::__set_isBroadcastable(const bool val) {
  this->isBroadcastable = val;
}

void CatalogTableObject::__set_viewOriginalText(const std::string& val) {
  this->viewOriginalText = val;
__isset.viewOriginalText = true;
}

void CatalogTableObject::__set_viewText(const std::string& val) {
  this->viewText = val;
__isset.viewText = true;
}

void CatalogTableObject::__set_comment(const std::string& val) {
  this->comment = val;
__isset.comment = true;
}

void CatalogTableObject::__set_unsupportedFeatures(const std::vector<std::string> & val) {
  this->unsupportedFeatures = val;
}

void CatalogTableObject::__set_tracksPartitionsInCatalog(const bool val) {
  this->tracksPartitionsInCatalog = val;
}

void CatalogTableObject::__set_schemaPreservesCase(const bool val) {
  this->schemaPreservesCase = val;
}

uint32_t CatalogTableObject::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_tableName = false;
  bool isset_tableType = false;
  bool isset_storage = false;
  bool isset_tableSchema = false;
  bool isset_partitionColumns = false;
  bool isset_indexColumns = false;
  bool isset_primaryKeyColumns = false;
  bool isset_bucketOwners = false;
  bool isset_bucketColumns = false;
  bool isset_sortColumns = false;
  bool isset_owner = false;
  bool isset_createTime = false;
  bool isset_lastAccessTime = false;
  bool isset_properties = false;
  bool isset_colStats = false;
  bool isset_isBroadcastable = false;
  bool isset_unsupportedFeatures = false;
  bool isset_tracksPartitionsInCatalog = false;
  bool isset_schemaPreservesCase = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableName);
          isset_tableName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->schemaName);
          this->__isset.schemaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableType);
          isset_tableType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->storage.read(iprot);
          isset_storage = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->tableSchema);
          isset_tableSchema = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->provider);
          this->__isset.provider = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->partitionColumns.clear();
            uint32_t _size336;
            ::apache::thrift::protocol::TType _etype339;
            xfer += iprot->readListBegin(_etype339, _size336);
            this->partitionColumns.resize(_size336);
            uint32_t _i340;
            for (_i340 = 0; _i340 < _size336; ++_i340)
            {
              xfer += iprot->readString(this->partitionColumns[_i340]);
            }
            xfer += iprot->readListEnd();
          }
          isset_partitionColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->indexColumns.clear();
            uint32_t _size341;
            ::apache::thrift::protocol::TType _etype344;
            xfer += iprot->readListBegin(_etype344, _size341);
            this->indexColumns.resize(_size341);
            uint32_t _i345;
            for (_i345 = 0; _i345 < _size341; ++_i345)
            {
              xfer += iprot->readString(this->indexColumns[_i345]);
            }
            xfer += iprot->readListEnd();
          }
          isset_indexColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->primaryKeyColumns.clear();
            uint32_t _size346;
            ::apache::thrift::protocol::TType _etype349;
            xfer += iprot->readListBegin(_etype349, _size346);
            this->primaryKeyColumns.resize(_size346);
            uint32_t _i350;
            for (_i350 = 0; _i350 < _size346; ++_i350)
            {
              xfer += iprot->readString(this->primaryKeyColumns[_i350]);
            }
            xfer += iprot->readListEnd();
          }
          isset_primaryKeyColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->numBuckets);
          this->__isset.numBuckets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->redundancy);
          this->__isset.redundancy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketOwners.clear();
            uint32_t _size351;
            ::apache::thrift::protocol::TType _etype354;
            xfer += iprot->readListBegin(_etype354, _size351);
            this->bucketOwners.resize(_size351);
            uint32_t _i355;
            for (_i355 = 0; _i355 < _size351; ++_i355)
            {
              xfer += this->bucketOwners[_i355].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          isset_bucketOwners = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->bucketColumns.clear();
            uint32_t _size356;
            ::apache::thrift::protocol::TType _etype359;
            xfer += iprot->readListBegin(_etype359, _size356);
            this->bucketColumns.resize(_size356);
            uint32_t _i360;
            for (_i360 = 0; _i360 < _size356; ++_i360)
            {
              xfer += iprot->readString(this->bucketColumns[_i360]);
            }
            xfer += iprot->readListEnd();
          }
          isset_bucketColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 14:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->sortColumns.clear();
            uint32_t _size361;
            ::apache::thrift::protocol::TType _etype364;
            xfer += iprot->readListBegin(_etype364, _size361);
            this->sortColumns.resize(_size361);
            uint32_t _i365;
            for (_i365 = 0; _i365 < _size361; ++_i365)
            {
              xfer += iprot->readString(this->sortColumns[_i365]);
            }
            xfer += iprot->readListEnd();
          }
          isset_sortColumns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 15:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->owner);
          isset_owner = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 16:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->createTime);
          isset_createTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 17:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastAccessTime);
          isset_lastAccessTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 18:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->properties.clear();
            uint32_t _size366;
            ::apache::thrift::protocol::TType _ktype367;
            ::apache::thrift::protocol::TType _vtype368;
            xfer += iprot->readMapBegin(_ktype367, _vtype368, _size366);
            uint32_t _i370;
            for (_i370 = 0; _i370 < _size366; ++_i370)
            {
              std::string _key371;
              xfer += iprot->readString(_key371);
              std::string& _val372 = this->properties[_key371];
              xfer += iprot->readString(_val372);
            }
            xfer += iprot->readMapEnd();
          }
          isset_properties = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 19:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->sizeInBytes);
          this->__isset.sizeInBytes = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->rowCount);
          this->__isset.rowCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 21:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->colStats.clear();
            uint32_t _size373;
            ::apache::thrift::protocol::TType _etype376;
            xfer += iprot->readListBegin(_etype376, _size373);
            this->colStats.resize(_size373);
            uint32_t _i377;
            for (_i377 = 0; _i377 < _size373; ++_i377)
            {
              {
                this->colStats[_i377].clear();
                uint32_t _size378;
                ::apache::thrift::protocol::TType _ktype379;
                ::apache::thrift::protocol::TType _vtype380;
                xfer += iprot->readMapBegin(_ktype379, _vtype380, _size378);
                uint32_t _i382;
                for (_i382 = 0; _i382 < _size378; ++_i382)
                {
                  std::string _key383;
                  xfer += iprot->readString(_key383);
                  std::string& _val384 = this->colStats[_i377][_key383];
                  xfer += iprot->readString(_val384);
                }
                xfer += iprot->readMapEnd();
              }
            }
            xfer += iprot->readListEnd();
          }
          isset_colStats = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 22:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isBroadcastable);
          isset_isBroadcastable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 23:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewOriginalText);
          this->__isset.viewOriginalText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 24:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewText);
          this->__isset.viewText = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->comment);
          this->__isset.comment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 26:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->unsupportedFeatures.clear();
            uint32_t _size385;
            ::apache::thrift::protocol::TType _etype388;
            xfer += iprot->readListBegin(_etype388, _size385);
            this->unsupportedFeatures.resize(_size385);
            uint32_t _i389;
            for (_i389 = 0; _i389 < _size385; ++_i389)
            {
              xfer += iprot->readString(this->unsupportedFeatures[_i389]);
            }
            xfer += iprot->readListEnd();
          }
          isset_unsupportedFeatures = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 27:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->tracksPartitionsInCatalog);
          isset_tracksPartitionsInCatalog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 28:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->schemaPreservesCase);
          isset_schemaPreservesCase = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_tableName)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableType)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_storage)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tableSchema)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_partitionColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_indexColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_primaryKeyColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bucketOwners)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_bucketColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_sortColumns)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_owner)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_createTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_lastAccessTime)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_properties)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_colStats)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_isBroadcastable)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_unsupportedFeatures)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_tracksPartitionsInCatalog)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_schemaPreservesCase)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t CatalogTableObject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  xfer += oprot->writeStructBegin("CatalogTableObject");

  xfer += oprot->writeFieldBegin("tableName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->tableName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.schemaName) {
    xfer += oprot->writeFieldBegin("schemaName", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->schemaName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("tableType", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->tableType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("storage", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->storage.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tableSchema", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->tableSchema);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.provider) {
    xfer += oprot->writeFieldBegin("provider", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->provider);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("partitionColumns", ::apache::thrift::protocol::T_LIST, 7);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->partitionColumns.size()));
    std::vector<std::string> ::const_iterator _iter390;
    for (_iter390 = this->partitionColumns.begin(); _iter390 != this->partitionColumns.end(); ++_iter390)
    {
      xfer += oprot->writeString((*_iter390));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("indexColumns", ::apache::thrift::protocol::T_LIST, 8);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->indexColumns.size()));
    std::vector<std::string> ::const_iterator _iter391;
    for (_iter391 = this->indexColumns.begin(); _iter391 != this->indexColumns.end(); ++_iter391)
    {
      xfer += oprot->writeString((*_iter391));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("primaryKeyColumns", ::apache::thrift::protocol::T_LIST, 9);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->primaryKeyColumns.size()));
    std::vector<std::string> ::const_iterator _iter392;
    for (_iter392 = this->primaryKeyColumns.begin(); _iter392 != this->primaryKeyColumns.end(); ++_iter392)
    {
      xfer += oprot->writeString((*_iter392));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.numBuckets) {
    xfer += oprot->writeFieldBegin("numBuckets", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->numBuckets);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.redundancy) {
    xfer += oprot->writeFieldBegin("redundancy", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->redundancy);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("bucketOwners", ::apache::thrift::protocol::T_LIST, 12);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bucketOwners.size()));
    std::vector<BucketOwners> ::const_iterator _iter393;
    for (_iter393 = this->bucketOwners.begin(); _iter393 != this->bucketOwners.end(); ++_iter393)
    {
      xfer += (*_iter393).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bucketColumns", ::apache::thrift::protocol::T_LIST, 13);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->bucketColumns.size()));
    std::vector<std::string> ::const_iterator _iter394;
    for (_iter394 = this->bucketColumns.begin(); _iter394 != this->bucketColumns.end(); ++_iter394)
    {
      xfer += oprot->writeString((*_iter394));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sortColumns", ::apache::thrift::protocol::T_LIST, 14);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->sortColumns.size()));
    std::vector<std::string> ::const_iterator _iter395;
    for (_iter395 = this->sortColumns.begin(); _iter395 != this->sortColumns.end(); ++_iter395)
    {
      xfer += oprot->writeString((*_iter395));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("owner", ::apache::thrift::protocol::T_STRING, 15);
  xfer += oprot->writeString(this->owner);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("createTime", ::apache::thrift::protocol::T_I64, 16);
  xfer += oprot->writeI64(this->createTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastAccessTime", ::apache::thrift::protocol::T_I64, 17);
  xfer += oprot->writeI64(this->lastAccessTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("properties", ::apache::thrift::protocol::T_MAP, 18);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->properties.size()));
    std::map<std::string, std::string> ::const_iterator _iter396;
    for (_iter396 = this->properties.begin(); _iter396 != this->properties.end(); ++_iter396)
    {
      xfer += oprot->writeString(_iter396->first);
      xfer += oprot->writeString(_iter396->second);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  if (this->__isset.sizeInBytes) {
    xfer += oprot->writeFieldBegin("sizeInBytes", ::apache::thrift::protocol::T_I64, 19);
    xfer += oprot->writeI64(this->sizeInBytes);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.rowCount) {
    xfer += oprot->writeFieldBegin("rowCount", ::apache::thrift::protocol::T_I64, 20);
    xfer += oprot->writeI64(this->rowCount);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("colStats", ::apache::thrift::protocol::T_LIST, 21);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_MAP, static_cast<uint32_t>(this->colStats.size()));
    std::vector<std::map<std::string, std::string> > ::const_iterator _iter397;
    for (_iter397 = this->colStats.begin(); _iter397 != this->colStats.end(); ++_iter397)
    {
      {
        xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRING, static_cast<uint32_t>((*_iter397).size()));
        std::map<std::string, std::string> ::const_iterator _iter398;
        for (_iter398 = (*_iter397).begin(); _iter398 != (*_iter397).end(); ++_iter398)
        {
          xfer += oprot->writeString(_iter398->first);
          xfer += oprot->writeString(_iter398->second);
        }
        xfer += oprot->writeMapEnd();
      }
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isBroadcastable", ::apache::thrift::protocol::T_BOOL, 22);
  xfer += oprot->writeBool(this->isBroadcastable);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.viewOriginalText) {
    xfer += oprot->writeFieldBegin("viewOriginalText", ::apache::thrift::protocol::T_STRING, 23);
    xfer += oprot->writeString(this->viewOriginalText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.viewText) {
    xfer += oprot->writeFieldBegin("viewText", ::apache::thrift::protocol::T_STRING, 24);
    xfer += oprot->writeString(this->viewText);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.comment) {
    xfer += oprot->writeFieldBegin("comment", ::apache::thrift::protocol::T_STRING, 25);
    xfer += oprot->writeString(this->comment);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("unsupportedFeatures", ::apache::thrift::protocol::T_LIST, 26);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->unsupportedFeatures.size()));
    std::vector<std::string> ::const_iterator _iter399;
    for (_iter399 = this->unsupportedFeatures.begin(); _iter399 != this->unsupportedFeatures.end(); ++_iter399)
    {
      xfer += oprot->writeString((*_iter399));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tracksPartitionsInCatalog", ::apache::thrift::protocol::T_BOOL, 27);
  xfer += oprot->writeBool(this->tracksPartitionsInCatalog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("schemaPreservesCase", ::apache::thrift::protocol::T_BOOL, 28);
  xfer += oprot->writeBool(this->schemaPreservesCase);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CatalogTableObject &a, CatalogTableObject &b) {
  using ::std::swap;
  swap(a.tableName, b.tableName);
  swap(a.schemaName, b.schemaName);
  swap(a.tableType, b.tableType);
  swap(a.storage, b.storage);
  swap(a.tableSchema, b.tableSchema);
  swap(a.provider, b.provider);
  swap(a.partitionColumns, b.partitionColumns);
  swap(a.indexColumns, b.indexColumns);
  swap(a.primaryKeyColumns, b.primaryKeyColumns);
  swap(a.numBuckets, b.numBuckets);
  swap(a.redundancy, b.redundancy);
  swap(a.bucketOwners, b.bucketOwners);
  swap(a.bucketColumns, b.bucketColumns);
  swap(a.sortColumns, b.sortColumns);
  swap(a.owner, b.owner);
  swap(a.createTime, b.createTime);
  swap(a.lastAccessTime, b.lastAccessTime);
  swap(a.properties, b.properties);
  swap(a.sizeInBytes, b.sizeInBytes);
  swap(a.rowCount, b.rowCount);
  swap(a.colStats, b.colStats);
  swap(a.isBroadcastable, b.isBroadcastable);
  swap(a.viewOriginalText, b.viewOriginalText);
  swap(a.viewText, b.viewText);
  swap(a.comment, b.comment);
  swap(a.unsupportedFeatures, b.unsupportedFeatures);
  swap(a.tracksPartitionsInCatalog, b.tracksPartitionsInCatalog);
  swap(a.schemaPreservesCase, b.schemaPreservesCase);
  swap(a.__isset, b.__isset);
}

CatalogTableObject::CatalogTableObject(const CatalogTableObject& other400) {
  tableName = other400.tableName;
  schemaName = other400.schemaName;
  tableType = other400.tableType;
  storage = other400.storage;
  tableSchema = other400.tableSchema;
  provider = other400.provider;
  partitionColumns = other400.partitionColumns;
  indexColumns = other400.indexColumns;
  primaryKeyColumns = other400.primaryKeyColumns;
  numBuckets = other400.numBuckets;
  redundancy = other400.redundancy;
  bucketOwners = other400.bucketOwners;
  bucketColumns = other400.bucketColumns;
  sortColumns = other400.sortColumns;
  owner = other400.owner;
  createTime = other400.createTime;
  lastAccessTime = other400.lastAccessTime;
  properties = other400.properties;
  sizeInBytes = other400.sizeInBytes;
  rowCount = other400.rowCount;
  colStats = other400.colStats;
  isBroadcastable = other400.isBroadcastable;
  viewOriginalText = other400.viewOriginalText;
  viewText = other400.viewText;
  comment = other400.comment;
  unsupportedFeatures = other400.unsupportedFeatures;
  tracksPartitionsInCatalog = other400.tracksPartitionsInCatalog;
  schemaPreservesCase = other400.schemaPreservesCase;
  __isset = other400.__isset;
}
CatalogTableObject::CatalogTableObject( CatalogTableObject&& other401) noexcept {
  tableName = std::move(other401.tableName);
  schemaName = std::move(other401.schemaName);
  tableType = std::move(other401.tableType);
  storage = std::move(other401.storage);
  tableSchema = std::move(other401.tableSchema);
  provider = std::move(other401.provider);
  partitionColumns = std::move(other401.partitionColumns);
  indexColumns = std::move(other401.indexColumns);
  primaryKeyColumns = std::move(other401.primaryKeyColumns);
  numBuckets = std::move(other401.numBuckets);
  redundancy = std::move(other401.redundancy);
  bucketOwners = std::move(other401.bucketOwners);
  bucketColumns = std::move(other401.bucketColumns);
  sortColumns = std::move(other401.sortColumns);
  owner = std::move(other401.owner);
  createTime = std::move(other401.createTime);
  lastAccessTime = std::move(other401.lastAccessTime);
  properties = std::move(other401.properties);
  sizeInBytes = std::move(other401.sizeInBytes);
  rowCount = std::move(other401.rowCount);
  colStats = std::move(other401.colStats);
  isBroadcastable = std::move(other401.isBroadcastable);
  viewOriginalText = std::move(other401.viewOriginalText);
  viewText = std::move(other401.viewText);
  comment = std::move(other401.comment);
  unsupportedFeatures = std::move(other401.unsupportedFeatures);
  tracksPartitionsInCatalog = std::move(other401.tracksPartitionsInCatalog);
  schemaPreservesCase = std::move(other401.schemaPreservesCase);
  __isset = std::move(other401.__isset);
}
CatalogTableObject& CatalogTableObject::operator=(const CatalogTableObject& other402) {
  tableName = other402.tableName;
  schemaName = other402.schemaName;
  tableType = other402.tableType;
  storage = other402.storage;
  tableSchema = other402.tableSchema;
  provider = other402.provider;
  partitionColumns = other402.partitionColumns;
  indexColumns = other402.indexColumns;
  primaryKeyColumns = other402.primaryKeyColumns;
  numBuckets = other402.numBuckets;
  redundancy = other402.redundancy;
  bucketOwners = other402.bucketOwners;
  bucketColumns = other402.bucketColumns;
  sortColumns = other402.sortColumns;
  owner = other402.owner;
  createTime = other402.createTime;
  lastAccessTime = other402.lastAccessTime;
  properties = other402.properties;
  sizeInBytes = other402.sizeInBytes;
  rowCount = other402.rowCount;
  colStats = other402.colStats;
  isBroadcastable = other402.isBroadcastable;
  viewOriginalText = other402.viewOriginalText;
  viewText = other402.viewText;
  comment = other402.comment;
  unsupportedFeatures = other402.unsupportedFeatures;
  tracksPartitionsInCatalog = other402.tracksPartitionsInCatalog;
  schemaPreservesCase = other402.schemaPreservesCase;
  __isset = other402.__isset;
  return *this;
}
CatalogTableObject& CatalogTableObject::operator=(CatalogTableObject&& other403) noexcept {
  tableName = std::move(other403.tableName);
  schemaName = std::move(other403.schemaName);
  tableType = std::move(other403.tableType);
  storage = std::move(other403.storage);
  tableSchema = std::move(other403.tableSchema);
  provider = std::move(other403.provider);
  partitionColumns = std::move(other403.partitionColumns);
  indexColumns = std::move(other403.indexColumns);
  primaryKeyColumns = std::move(other403.primaryKeyColumns);
  numBuckets = std::move(other403.numBuckets);
  redundancy = std::move(other403.redundancy);
  bucketOwners = std::move(other403.bucketOwners);
  bucketColumns = std::move(other403.bucketColumns);
  sortColumns = std::move(other403.sortColumns);
  owner = std::move(other403.owner);
  createTime = std::move(other403.createTime);
  lastAccessTime = std::move(other403.lastAccessTime);
  properties = std::move(other403.properties);
  sizeInBytes = std::move(other403.sizeInBytes);
  rowCount = std::move(other403.rowCount);
  colStats = std::move(other403.colStats);
  isBroadcastable = std::move(other403.isBroadcastable);
  viewOriginalText = std::move(other403.viewOriginalText);
  viewText = std::move(other403.viewText);
  comment = std::move(other403.comment);
  unsupportedFeatures = std::move(other403.unsupportedFeatures);
  tracksPartitionsInCatalog = std::move(other403.tracksPartitionsInCatalog);
  schemaPreservesCase = std::move(other403.schemaPreservesCase);
  __isset = std::move(other403.__isset);
  return *this;
}
void CatalogTableObject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CatalogTableObject(";
  out << "tableName=" << to_string(tableName);
  out << ", " << "schemaName="; (__isset.schemaName ? (out << to_string(schemaName)) : (out << "<null>"));
  out << ", " << "tableType=" << to_string(tableType);
  out << ", " << "storage=" << to_string(storage);
  out << ", " << "tableSchema=" << to_string(tableSchema);
  out << ", " << "provider="; (__isset.provider ? (out << to_string(provider)) : (out << "<null>"));
  out << ", " << "partitionColumns=" << to_string(partitionColumns);
  out << ", " << "indexColumns=" << to_string(indexColumns);
  out << ", " << "primaryKeyColumns=" << to_string(primaryKeyColumns);
  out << ", " << "numBuckets="; (__isset.numBuckets ? (out << to_string(numBuckets)) : (out << "<null>"));
  out << ", " << "redundancy="; (__isset.redundancy ? (out << to_string(redundancy)) : (out << "<null>"));
  out << ", " << "bucketOwners=" << to_string(bucketOwners);
  out << ", " << "bucketColumns=" << to_string(bucketColumns);
  out << ", " << "sortColumns=" << to_string(sortColumns);
  out << ", " << "owner=" << to_string(owner);
  out << ", " << "createTime=" << to_string(createTime);
  out << ", " << "lastAccessTime=" << to_string(lastAccessTime);
  out << ", " << "properties=" << to_string(properties);
  out << ", " << "sizeInBytes="; (__isset.sizeInBytes ? (out << to_string(sizeInBytes)) : (out << "<null>"));
  out << ", " << "rowCount="; (__isset.rowCount ? (out << to_string(rowCount)) : (out << "<null>"));
  out << ", " << "colStats=" << to_string(colStats);
  out << ", " << "isBroadcastable=" << to_string(isBroadcastable);
  out << ", " << "viewOriginalText="; (__isset.viewOriginalText ? (out << to_string(viewOriginalText)) : (out << "<null>"));
  out << ", " << "viewText="; (__isset.viewText ? (out << to_string(viewText)) : (out << "<null>"));
  out << ", " << "comment="; (__isset.comment ? (out << to_string(comment)) : (out << "<null>"));
  out << ", " << "unsupportedFeatures=" << to_string(unsupportedFeatures);
  out << ", " << "tracksPartitionsInCatalog=" << to_string(tracksPartitionsInCatalog);
  out << ", " << "schemaPreservesCase=" << to_string(schemaPreservesCase);
  out << ")";
}

}}} // namespace
